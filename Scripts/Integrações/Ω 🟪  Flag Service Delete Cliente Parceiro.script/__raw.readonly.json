{
  "ssjsActivityId": "aadf94a9-dbc3-47ee-8279-c94c38280fe2",
  "name": "Flag Service Delete Cliente Parceiro",
  "key": "1afa9056-0e12-4292-8da2-81a7362aac7c",
  "description": "Marca no Service um campo para deletar o cliente Parceiro",
  "script": "<script runat=\"server\">\nPlatform(\"Core\", \"2.0\");\nvar api = new Script.Util.WSProxy();\nvar nameDE = 'Atualizacao Flag Delete Cliente Parceiro';\nvar SOBJECTTYPE = 'HC_Relacao_Cliente_Parceiro__c';\nvar deCustomerkey = retrieveDECustomerKeyFromName(api, nameDE);\nvar urlToUpsert = 'https://brasilcap.my.salesforce.com/services/data/v54.0/composite/';\nvar BATCH_SIZE = 1000;\nvar MAX_COMPOSITE_SUBREQUEST_SIZE = 200;\nvar logDEName = 'Log Integracao Flag Cliente Parceiro';\nvar logDECustomerKey = retrieveDECustomerKeyFromName(api, logDEName);\nvar START_TIME = new Date().getTime();\nvar MAX_EXECUTION_TIME_MILISECONDS = 60 * 28 * 1000;\nvar DATETIME_ENVIO;\n\n// Faz depara de campos (<nome_do_campo_DE> : <nome_do_campo_Payload>)\nvar DEPARACAMPOS = {\n  \"Id\": \"Id\"\n}\n\n// Usar caso haja valores para inserir carimbados (que não são variáveis de acordo com a base)\nvar VALORESFIXOS = {\n  \"HC_CustomerToBeDeleted_Flg__c\": true\n}\n\n// DE OTC291 filtrado\nvar campoPKNoDEParaAtualizar = 'Id';\n\n// Formatar campos de data para formato YYYY-MM-DD\n// Usar lado direito no caso do objeto deparaCampos\n// var dateFieldsToFormat = [\n//   'Date'\n// ];\n\n// Aplicar um filtro para trazer do DE apenas linhas desejadas\nvar applyFilterRetrieve = true; // flag para usar o filtro \"filterRetrieveRows\"\n// Campo para atualizar o DE informando que um contato já teve a tentativa de disparo\n// Para caso o Script precise ser executado novamente\nvar flagEnvioParaService = 'Enviado';\nvar filterRetrieveRows = {\n  Property: flagEnvioParaService,\n  SimpleOperator: 'equals',\n  Value: false\n}\n\n// Configs\n\n\ntry {\n  var deCustomerkey = retrieveDECustomerKeyFromName(api, nameDE);\n  var requestAccessTokenFunction = eval(Platform.Function.TreatAsContent( Platform.Function.ContentBlockByID('56359') ));\n  var access_token = requestAccessTokenFunction();\n  \n  var recordManipulator = DataExtensionRecordsOperator({api: api, dataExtensionName: nameDE});\n  \n  recordManipulator.pipeExecuteInAllRecords({filter: filterRetrieveRows}, myCallback, BATCH_SIZE);\n  \n  function myCallback(records){\n    var currentRecords = records;\n    var payloadComposite = {\n      \"allOrNone\" : false,\n      \"collateSubrequests\": false,\n      \"compositeRequest\": []\n    }\n    var currentRecord = {};\n    // var indexSubrequest = 0;\n    var queueToNextRequest = []; // Para quando não houver espaço para o envio num mesmo compositeRequest\n  \n    // Write('Starting' + '\\n');\n  \n    while(currentRecords.length > 0){\n      // Write('currentRecords.length' + '\\n');\n      // Write(Stringify(currentRecords.length) + '\\n\\n');\n      currentRecord = currentRecords.shift();\n      var requestMethodForRecord = getMethodForRecord(currentRecord);\n  \n  \n      var indexToInsertRecord = getIndexToInsertRecord(payloadComposite, requestMethodForRecord);\n      if(indexToInsertRecord >= 5){\n        // Não é possível inserir o contato nesse request, tentar na próxima request\n        queueToNextRequest.push(currentRecord);\n      }else{\n        payloadComposite = insereRecordNoPayload(payloadComposite, currentRecord, indexToInsertRecord, requestMethodForRecord);\n      }\n      \n      \n      // Fazer envio quando não há mais records para ser avaliados, ou quando o payload está com carga máxima\n      if(currentRecords.length == 0 || payloadCompositeNaCapacidadeMaxima(payloadComposite)){\n        // Logica de envio\n        DATETIME_ENVIO = new Date();\n        var resp = enviarDadosParaService(payloadComposite);\n        \n        // Guardar resposta\n        var response = Platform.Function.ParseJSON('' + resp.content); // trata resposta\n        updateDEResposta(payloadComposite, response);\n  \n        // limpar base de envio\n        payloadComposite.compositeRequest = [];\n      }\n  \n      // Reinicia a fila, quando já tentou enviar todos os registros      \n      if(queueToNextRequest.length > 0 && currentRecords.length == 0){\n        // Write('Restarting Queue' + '\\n');\n        currentRecords = queueToNextRequest;\n      }\n  \n      currentRecord = {};\n    }\n  \n  }\n  \n  } catch (error) {\n  // Write('error' + '\\n');\n  // Write(Platform.Function.Stringify(error) + '\\n\\n');\n  insertBulkRecordInDE(api, [{Data_Sent:Platform.Function.Stringify(error)}], logDECustomerKey);\n  }\n  \n  function createSingleRecordComposite(record, sObjectType, deparaCampos, valoresFixos){\n  var recordFormated = {\n    \"attributes\": {\n      \"type\": sObjectType\n    }\n  }\n  \n  for (var key in deparaCampos) {\n    recordFormated[ deparaCampos[key] ] = record[key];\n  }\n  \n  // se houver algum valor fixo, inserir no payload\n  if(valoresFixos){\n    for (var key in valoresFixos) {\n      recordFormated[ key ] = valoresFixos[key];\n    }\n  }\n  \n  // formata campo de data se houver\n  for(var key in recordFormated){\n    if(key == \"attributes\") continue\n    \n    if(dateFieldsToFormat && dateFieldsToFormat.length > 0){\n      for (var i = 0; i < dateFieldsToFormat.length; i++) {\n        if(key == dateFieldsToFormat[i]){\n          recordFormated[key] = formatDate(recordFormated[key]);\n        }\n      }\n    }\n  }\n  \n  return recordFormated;\n  }\n  \n  function recordUpdateCampaignMemberCompositePayload(record, sObjectType){\n  var recordFormated = {\n    \"attributes\": {\n      \"type\": sObjectType\n    }\n  }\n  \n  recordFormated.Id = record[DEPARACAMPOID_SERVICE];\n  recordFormated[ DEPARACAMPOS[campoPKNoDEParaAtualizar] ] = record[campoPKNoDEParaAtualizar];\n  recordFormated.HC_DISPARO_CAMPANHA__c = formatDate( new Date() );\n  \n  return recordFormated;\n  }\n  \n  function DataExtensionRecordsOperator(configuration){\n  var api;\n  var customerKey;\n  \n  if(!configuration) Platform.Function.RaiseError('An configuration Object is required');\n  if(!configuration.api) Platform.Function.RaiseError('Api attribute is required');\n  if(!configuration.dataExtensionCustomerKey && !configuration.dataExtensionName) Platform.Function.RaiseError('dataExtensionCustomerKey or dataExtensionName attribute is required');\n  if(configuration.dataExtensionCustomerKey && typeof configuration.dataExtensionCustomerKey != 'string') Platform.Function.RaiseError('dataExtensionCustomerKey must be a String');\n  api = configuration.api;\n  \n  if(configuration.dataExtensionCustomerKey == null || configuration.dataExtensionCustomerKey == ''){\n    var simpleFilter = {\n      Property: 'Name',\n      SimpleOperator: 'equals',\n      Value: configuration.dataExtensionName\n    }\n    customerKey = api.retrieve(\"DataExtension\", [\"CustomerKey\"], simpleFilter).Results[0].CustomerKey;\n  }else{\n    customerKey = configuration.dataExtensionCustomerKey;\n  }\n  \n  function getRecords(options){\n    // options Object can have filter or headers\n    if(!!options && typeof options != 'object') Platform.Function.RaiseError('Options must be an object or omitted');\n        \n    var headers;\n    var filter;\n  \n    if(!!options && options.headers){\n      headers = options.headers;\n    }else{\n      headers = retrieveFieldNames(customerKey, api);\n    }\n  \n    if(!!options && options.filter) filter = options.filter;\n  \n    var config = {\n      customerKey: customerKey,\n      cols: headers\n    }\n  \n    var records = [],\n    moreData = true,\n    reqID = data = null;\n  \n    while (moreData) {\n      moreData = false;\n      if (reqID == null) {\n        if(filter == undefined || filter == null){\n          data = api.retrieve(\"DataExtensionObject[\" + config.customerKey + \"]\", config.cols);\n        }else{\n          data = api.retrieve(\"DataExtensionObject[\" + config.customerKey + \"]\", config.cols, filter);\n        }\n        if(data.Status.substring(0, 5) == 'Error'){\n          Platform.Function.RaiseError('Something went wrong: ' + data.Status);\n        }\n      } else {\n        data = api.getNextBatch(\"DataExtensionObject[\" + config.customerKey + \"]\", reqID);\n      }\n  \n      if (data != null) {\n        moreData = data.HasMoreRows;\n        reqID = data.RequestID;\n        for (var i = 0; i < data.Results.length; i++) {\n          var result_list = data.Results[i].Properties;\n          var obj = {};\n          for (k in result_list) {\n            var key = result_list[k].Name;\n            var val = result_list[k].Value\n            if (key.indexOf(\"_\") != 0) obj[key] = val;\n          }\n        records.push(obj);\n        }\n      }\n    }\n    return records;\n    \n  }\n  \n  function pipeExecuteInAllRecords(options, cb, batchSize){\n    // options Object can have filter or headers\n    if(!!options && typeof options != 'object') Platform.Function.RaiseError('Options must be an object or omitted');\n    var batchSizeActual = batchSize == null || batchSize == undefined ? 2500 : batchSize;\n    batchSizeActual = batchSizeActual > 2500 ? 2500 : batchSizeActual;\n    if(batchSizeActual == 0) Platform.Function.RaiseError('batchSize cannot be 0');\n        \n    var filter;\n    headers = retrieveFieldNames(customerKey, api);\n  \n    if(!!options && options.filter) filter = options.filter;\n  \n    var config = {\n      customerKey: customerKey,\n      cols: headers\n    }\n  \n    var records = [],\n    moreData = true,\n    reqID = data = null;\n  \n    while (moreData) {\n      moreData = false;\n      if (reqID == null) {\n        if(filter == undefined || filter == null){\n          data = api.retrieve(\"DataExtensionObject[\" + config.customerKey + \"]\", config.cols);\n        }else{\n          data = api.retrieve(\"DataExtensionObject[\" + config.customerKey + \"]\", config.cols, filter);\n        }\n        if(data.Status.substring(0, 5) == 'Error'){\n          Platform.Function.RaiseError('Something went wrong: ' + data.Status);\n        }\n      } else {\n        data = api.getNextBatch(\"DataExtensionObject[\" + config.customerKey + \"]\", reqID);\n      }\n  \n      if (data != null) {\n        moreData = data.HasMoreRows;\n        reqID = data.RequestID;\n        var retrievedData = data.Results;\n        while ( retrievedData.length != 0 ) {\n          var currentData = retrievedData.splice(0, batchSizeActual);\n          for (var i = 0; i < currentData.length; i++) {\n            var result_list = currentData[i].Properties;\n            var obj = {};\n            for (k in result_list) {\n              var key = result_list[k].Name;\n              var val = result_list[k].Value\n              if (key.indexOf(\"_\") != 0) obj[key] = val;\n            }\n            records.push(obj);\n          }\n          cb(records); // operate over the first Chunck\n          records = []; // clear records, free up memory\n          // Se estiver em um tempo próximo de ocorrer erro por timeout na atividade de execução de script,\n          // interrompe a execução\n          if(START_TIME != null && START_TIME != undefined && (new Date().getTime() - START_TIME > MAX_EXECUTION_TIME_MILISECONDS)){\n            moreData = false;\n          }\n        }\n      }\n    }\n  }\n  \n  function retrieveFieldNames(customerKey, api) {\n    var filter = {\n      Property: \"DataExtension.CustomerKey\",\n      SimpleOperator: \"equals\",\n      Value: customerKey\n    };\n  \n    var req = api.retrieve(\"DataExtensionField\", [\"Name\"], filter);\n    var fields = req.Results;\n    var out = [];\n    for (k in fields) {\n      out = out.concat(fields[k].Name);\n    }\n    return out;\n  }\n  \n  return {\n    getRecords: getRecords,\n    pipeExecuteInAllRecords: pipeExecuteInAllRecords\n  }\n  }\n  \n  function retrieveDECustomerKeyFromName(api, dataExtensionName){\n  var simpleFilter = {\n    Property: 'Name',\n    SimpleOperator: 'equals',\n    Value: dataExtensionName\n  }\n  var result = api.retrieve('DataExtension', ['CustomerKey'], simpleFilter);\n  if(result.Status != 'OK' || result.Results.length < 1){\n    return null\n  }else{\n    return result.Results[0].CustomerKey;\n  }\n  }\n  \n  function formatDate(date) {\n  var d = new Date(date),\n      month = '' + (d.getMonth() + 1),\n      day = '' + d.getDate(),\n      year = d.getFullYear()\n  if (month.length < 2) \n      month = '0' + month;\n  if (day.length < 2) \n      day = '0' + day;\n  hours = hours.length < 2 ? '0' + hours : hours;\n  minutes = minutes.length < 2 ? '0' + minutes : minutes;\n  seconds = seconds.length < 2 ? '0' + seconds : seconds;\n  var formattedDate = year + '-' + month + '-' + day;\n  return formattedDate;\n  }\n  \n  function insertBulkRecordInDE(api, records, customerKey){\n  if(!api) Platform.Function.RaiseError('Api param is required');\n  var data = [];\n  for(var recordIndex = 0; recordIndex < records.length ; recordIndex++){\n    var record = records[recordIndex];\n    var props = [];\n    for (prop in record) {\n      props.push({ Name: prop, Value: record[prop] });\n    }\n    data.push({\n      CustomerKey: customerKey,\n      Properties: props\n    });\n  }\n  return api.createBatch('DataExtensionObject', data);\n  }\n  \n  function upsertBulkRecordInDE(api, records, customerKey){\n  if(!api) Platform.Function.RaiseError('Api param is required');\n  var data = [];\n  for(var recordIndex = 0; recordIndex < records.length ; recordIndex++){\n    var record = records[recordIndex];\n    var props = [];\n    for (prop in record) {\n      props.push({ Name: prop, Value: record[prop] });\n    }\n    data.push({\n      CustomerKey: customerKey,\n      Properties: props\n    });\n  }\n  return api.updateBatch('DataExtensionObject', data, {SaveOptions: [{'PropertyName': '*', SaveAction: 'UpdateAdd'}]});\n  }\n  \n  function createCompositeSubrequest(method, refId){\n  return  {\n    \"method\" : method,\n    \"url\" : \"/services/data/v54.0/composite/sobjects/\",\n    \"referenceId\": refId,\n    \"body\" : {\n      \"allOrNone\" : false,\n      \"records\" : [\n      ]\n    }\n  }\n  }\n  \n  function getMethodForRecord(record){\n  // if(record.Id_Membro_Campanha == null || record.Id_Membro_Campanha == undefined || record.Id_Membro_Campanha == '') return 'POST';\n  return 'PATCH';\n  }\n  \n  function getIndexToInsertRecord(payloadComposite, requestMethod){\n  // verificar se o metodo na subrequest atual (POST ou PATCH) é o mesmo do record atual\n  // e se há espaço para enviar esse record (max 200 records por subrequest)\n  var indexSubrequest = 0;\n  for(indexSubrequest = 0; indexSubrequest < 5 ; indexSubrequest++){\n  \n    // Ainda não existe essa subrequest, então o contato pode ser inserido nesse index\n    if(!payloadComposite.compositeRequest[indexSubrequest]) return indexSubrequest;\n    \n    // existe um objeto e ele é do mesmo method\n    if(payloadComposite.compositeRequest[indexSubrequest].method == requestMethod \n      && payloadComposite.compositeRequest[indexSubrequest].body.records.length < MAX_COMPOSITE_SUBREQUEST_SIZE) return indexSubrequest;\n  }\n  return indexSubrequest;\n  }\n  \n  function payloadCompositeNaCapacidadeMaxima(payloadComposite){\n  for(var i = 0; i < 5 ; i++){\n    // Ainda não existe essa subrequest, então não está completo\n    if(!payloadComposite.compositeRequest[i]) return false;\n    \n    // existe um objeto e ele é do mesmo method\n    if(payloadComposite.compositeRequest[i].body.records.length < MAX_COMPOSITE_SUBREQUEST_SIZE) return false;\n  }\n  return true;\n  }\n  \n  function insereRecordNoPayload(payloadComposite, record, indexToInsertRecord, requestMethodForRecord){\n  // Confere se há um composite subrequest criado e insere (ou cria e insere)\n  if(!payloadComposite.compositeRequest[indexToInsertRecord]) payloadComposite.compositeRequest.push(createCompositeSubrequest(requestMethodForRecord, 'request'+indexToInsertRecord));\n  \n  // Adiciona o record fazendo tratativa\n  // Para update\n  if(!!DEPARACAMPOID_SERVICE && DEPARACAMPOID_SERVICE != '' && requestMethodForRecord == 'PATCH'){\n    var formattedRecord = recordUpdateCampaignMemberCompositePayload(record, SOBJECTTYPE);    \n    formattedRecord = includeIDField(formattedRecord, record);\n  }else{ // Para insert\n    var formattedRecord = createSingleRecordComposite(record, SOBJECTTYPE, DEPARACAMPOS, VALORESFIXOS);\n  }\n  \n  payloadComposite.compositeRequest[indexToInsertRecord].body.records.push( formattedRecord );\n  \n  return payloadComposite;\n  }\n  \n  function includeIDField(formattedRecord, retrieveRecordFromDE){\n  formattedRecord.Id = retrieveRecordFromDE[DEPARACAMPOID_SERVICE];\n  return formattedRecord;\n  }\n  \n  function updateDEResposta(payloadEnviado, payloadResposta){\n    var logsToDE = [];\n    var sent_DE_dados = [];\n  \n    var subRequestEnviado = {};\n    var subRequestResposta = {};\n    var errorInSend = payloadResposta[0].errorCode == null;\n    for (var subRequest = 0; subRequest < payloadEnviado.compositeRequest.length; subRequest++) {\n      subRequestEnviado = payloadEnviado.compositeRequest[subRequest];\n      subRequestResposta = payloadResposta.compositeResponse[subRequest];\n      \n      for(var row = 0; row < subRequestEnviado.body.records.length; row++){\n        var recordEnviado = subRequestEnviado.body.records[row];\n        var recordResposta = subRequestResposta.body[row];\n        \n        // dados de log\n        var logData = {\n          IdClienteParceiro: recordEnviado.Id,\n          Date: DATETIME_ENVIO,\n          Envio: Platform.Function.Stringify(recordEnviado).substring(0, 2000),\n          Resultado: Platform.Function.Stringify(recordResposta).substring(0, 2000)\n        }\n        logsToDE.push(logData);\n  \n        // dados para atualizar o DE que insere no Service com os Ids\n        var sentDERow = {}\n        sentDERow[campoPKNoDEParaAtualizar] = recordEnviado[ DEPARACAMPOS[campoPKNoDEParaAtualizar] ];\n        sentDERow[flagEnvioParaService] = true; // campo de flag para guardar no DE que essa linha já foi disparada para o Service\n        sent_DE_dados.push(sentDERow);\n      }\n  \n      subRequestEnviado = {};\n      subRequestResposta = {};\n      recordEnviado = {};\n      recordResposta = {};\n    }\n  \n    insertBulkRecordInDE(api, logsToDE, logDECustomerKey); // Insere no DE de log\n    upsertBulkRecordInDE(api, sent_DE_dados, deCustomerkey); // Insere a resposta do ID no DE de extração (OTC291 fitlrada)\n  }\n  \n  function enviarDadosParaService(payloadComposite){\n    var auth = 'Bearer ' + access_token;\n  \n    var req = new Script.Util.HttpRequest(urlToUpsert);\n    req.emptyContentHandling = 1;\n    req.retries = 2;\n    req.continueOnError = true;\n    req.contentType = \"application/json;charset=UTF-8\"\n    req.setHeader(\"Accept\", '*/*');\n    req.setHeader(\"Accept-Encoding\", 'gzip, deflate, br');\n    req.setHeader(\"Authorization\", auth);\n    req.method = \"POST\";\n  \n    var stringifiedPayload = Platform.Function.Stringify(payloadComposite);\n    var data = stringifiedPayload;\n  \n    req.postData = data;\n    return req.send();\n  }\n\n</script>",
  "categoryId": 49169,
  "createdDate": "2022-05-20T22:34:13.867",
  "modifiedDate": "2022-05-26T19:26:56.977"
}